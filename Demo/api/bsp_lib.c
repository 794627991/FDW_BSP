/*
*********************************************************************************************************
*
*	模块名称 : 数据转换程序
*	文件名称 : bsp_lib.c
*	版    本 : V1.0.1
*	说    明 : 全部API用到的数据转化或者通用的函数都在这里,提供一些常用的sting、mem操作函数以及Modbus CRC16函数
*	修改记录 :
*
*		版本号     日期      作者    说明
*		V1.0.0  2020-12-31  高屹    正式发布
*		V1.0.1  2020-2-1    高屹    新增ipv4全面判断，代替原先的ip判断方式
*
*	Copyright (C), 2020-2030,  辽宁思凯-高屹
*
*********************************************************************************************************
*/
#include "bsp_lib.h"

// CRC 高位字节值表
static const uint8_t s_CRCHi[] = {
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40};
// CRC 低位字节值表
const uint8_t s_CRCLo[] = {
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
    0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
    0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
    0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
    0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
    0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
    0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
    0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
    0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
    0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
    0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,
    0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
    0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
    0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
    0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
    0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
    0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
    0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
    0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
    0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
    0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
    0x43, 0x83, 0x41, 0x81, 0x80, 0x40};

/*
*********************************************************************************************************
*	函 数 名: mystrlen
*	功能说明: 计算指定长度字符串长度
*	形    参: s   ：输入的字符串
*             len ：长度限制
*	返 回 值: 转换结果
*	备    注：无
*********************************************************************************************************
*/
size_t mystrlen(const char *s, uint16_t len)
{
    /* find length of s[] */
    const char *sc;
    uint16_t i = 0;

    for (sc = s; *sc != '\0'; ++sc)
    {
        i++;
        if (i > len)
            break;
    }
    return (sc - s);
}
/*
*********************************************************************************************************
*	函 数 名: strnstr
*	功能说明: 比较两个字符串是否有相同内容，限制长度，并且比较长度
*	形    参: src   ：需要比较的母串
*             substr ：需要比较的子串
*             len ： 需要比较的长度
*             limt_len ： 限制长度
*	返 回 值: 转换结果
*	备    注：无
*********************************************************************************************************
*/
char *strnstr(const char *src, const char *substr, uint8_t len, uint8_t limt_len)
{
    const char *p;

    if (src == NULL || 0 == *src || substr == NULL || 0 == *substr || limt_len == 0 || len == 0)
    {
        return NULL;
    }

    p = src;

    while (limt_len)
    {
        if (*p == *substr)
        {
            if (memcmp(p, substr, len) == 0)
            {
                return (char *)p;
            }
        }
        p++;
        limt_len--;
    }

    return NULL;
}
/*
*********************************************************************************************************
*	函 数 名: BinToChar
*	功能说明: 将BCD码转为ASCII字符。 比如 0x0A ==> 'A' 16进制数0-15转成ascii的'0'-'9'和'a'-'f'
*	形    参: _bcd   ：输入的二进制数。必须小于16
*	返 回 值: 转换结果
*	备    注：无
*********************************************************************************************************
*/
char BinToChar(uint8_t _bcd)
{
    if (_bcd < 10)
    {
        return _bcd + '0';
    }
    else if (_bcd < 16)
    {
        return _bcd + 'A';
    }
    else
    {
        return 0;
    }
}
/*
*********************************************************************************************************
*	函 数 名: HexToAscll
*	功能说明: 将二进制数组转换为16进制格式的ASCII字符串。
*			  		0x12 0x34 转化为 0x31 0x32 0x33 0x34  即 "1234"
*	形    参: p2 ：输入的数据，二进制数组
*			  p1 ：存放转换结果, ASCII字符串，\0结束。1个二进制对应2个ASCII字符.
*	返 回 值: 无
*	备    注：小心数组溢出 p1的大小至少是p2大小的 2n+1 倍！！！
*********************************************************************************************************
*/
void HexToAscll(char *p1, uint8_t *p2, uint16_t length)
{
    uint32_t i = 0, k = 0;
    for (i = 0; i < length; i++)
    {
        k = i << 1;
        /* 高半字节 */
        p1[k] = p2[i] & 0xf0;
        p1[k] >>= 4;
        if (p1[k] <= 9)
        {
            p1[k] |= 0x30;
        }
        else if (p1[k] <= 15)
        {
            p1[k] = p1[k] - 10 + 'A';
        }
        /* 低半字节 */
        p1[k + 1] = p2[i] & 0x0f;
        if (p1[k + 1] <= 9)
        {
            p1[k + 1] |= 0x30;
        }
        else if (p1[k + 1] <= 15)
        {
            p1[k + 1] = p1[k + 1] - 10 + 'A';
        }
    }
    p1[2 * length] = '\0'; /* 字符结束 */
}
/*
*********************************************************************************************************
*	函 数 名: AsciiToHex
*	功能说明: 将ASCII字符串转成16进制格式的数组。
*			  0x31 0x32 0x33 0x34  即 "1234"  转化为  0x12 0x34
*	形    参: 	_pHex   ：输入的数据，二进制数组
*				_pAscii ：存放转换结果, ASCII字符串，0结束。1个二进制对应2个ASCII字符.
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void AsciiToHex(uint8_t *code, uint8_t *decode, uint16_t len)
{
    uint16_t i = 0;
    uint8_t j = 0, k = 0;
    for (i = 0; i < len; i++)
    {
        if ((code[i * 2] <= 0x39) && (code[i * 2] >= 0x30))
        {
            j = code[i * 2] - 0x30;
        }
        else if ((code[i * 2] <= 0x46) && (code[i * 2] >= 0x40))
        {
            j = code[i * 2] - 0x40 + 0x09;
        }
        else if ((code[i * 2] <= 0x66) && (code[i * 2] >= 0x60))
        {
            j = code[i * 2] - 0x60 + 0x09;
        }
        if ((code[i * 2 + 1] <= 0x39) && (code[i * 2 + 1] >= 0x30))
        {
            k = code[i * 2 + 1] - 0x30;
        }
        else if ((code[i * 2 + 1] <= 0x46) && (code[i * 2 + 1] >= 0x40))
        {
            k = code[i * 2 + 1] - 0x40 + 0x09;
        }
        else if ((code[i * 2 + 1] <= 0x66) && (code[i * 2 + 1] >= 0x60))
        {
            k = code[i * 2 + 1] - 0x60 + 0x09;
        }
        decode[i] = ((j << 4) + k);
    }
}
/*
*********************************************************************************************************
*	函 数 名: CharToHex
*	功能说明: char 转 hex  ASCII的'0'-'9' 'a'-'f' 'A'-'F' 转成 0-15
*	形    参: cd : 待转换的ASCII码字符
*	返 回 值: 转化后的hex
*	备    注：无
*********************************************************************************************************
*/
uint8_t CharToHex(char ch)
{
    if ((ch >= '0') && (ch <= '9'))
        return ch - 0x30;
    else if ((ch >= 'A') && (ch <= 'F'))
        return ch - 'A' + 10;
    else if ((ch >= 'a') && (ch <= 'f'))
        return ch - 'a' + 10;
    else
        return (0x20);
}
/*
*********************************************************************************************************
*	函 数 名: CharToBety
*	功能说明: char 转 bety
*	形    参: iput : 待转换的ASCII码串
*             oput : 目标缓冲区, 存放转换后的结果。
*             len : 整数 要转的长度
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void CharToBety(uint8_t *iput, uint8_t *oput, uint8_t len)
{
    uint8_t i = 0, b = 0;
    for (i = 0; i < len; i++)
    {
        b = CharToHex(iput[i << 1]) << 4;
        b += CharToHex(iput[(i << 1) + 1]);
        oput[i] = b;
    }
}
/*
*********************************************************************************************************
*	函 数 名: HEXtoBCD
*	功能说明:
*	形    参:
*	返 回 值:
*	备    注：无
*********************************************************************************************************
*/
uint8_t HEXtoBCD(uint8_t hex_data)
{
    return (hex_data / 10 * 16 + hex_data % 10);
}

/*
*********************************************************************************************************
*	函 数 名: BCDtoHEX
*	功能说明:
*	形    参:
*	返 回 值:
*	备    注：无
*********************************************************************************************************
*/
uint8_t BCDtoHEX(uint8_t bcd_data)
{
    return (bcd_data / 16 * 10 + bcd_data % 16);
}
/*
*********************************************************************************************************
*	函 数 名: MathCrc16
*	功能说明: CRC16
*	形    参:
*	返 回 值:
*	备    注：无
*********************************************************************************************************
*/
uint16_t MathCrc16(uint8_t *ptr, uint16_t len)
{
    uint16_t crc_val = 0xffff;
    uint16_t tmp = 0;
    uint16_t i = 0;
    while (len > 0)
    {
        crc_val ^= *ptr;
        ptr++;
        for (i = 0; i < 8; i++)
        {
            tmp = crc_val;
            crc_val >>= 1; /* CRC 校验字节的右移，最低位到 C，最高位补 0 */
            if ((tmp & 0x01) == 1)
                crc_val ^= 0xA001; /* 采用的多项式是： 0xA001 */
        }
        len--;
    }
    return (crc_val);
}
/*
*********************************************************************************************************
*	函 数 名: CheckSum
*	功能说明: 计算校验和
*	形    参: parray校验对象，size对象长度，op->操作类型0表示计算和，非0表示校验
*	返 回 值: 0表示校验和不正确，非零表示返回的的计算和。
*	备    注：无
*********************************************************************************************************
*/
uint8_t CheckSum(uint8_t *parray, uint32_t size, uint8_t op)
{
    uint32_t i = 0;
    uint8_t sum = 0;
    for (i = 0; i < size; i++)
    {
        sum += parray[i];
    }
    if (op)
    {
        if (sum != parray[size])
            sum = 0;
        else
            sum = 1;
    }
    return (sum);
}
/*
*********************************************************************************************************
*	函 数 名: calcCheckCrc
*	功能说明: 计算CRC
*	形    参: pdata校验对象，length对象长度
*	返 回 值: 返回CRC。
*	备    注：无
*********************************************************************************************************
*/
uint16_t calcCheckCrc(uint8_t *pdata, uint16_t length)
{
    uint16_t crc = 0xffff;
    uint32_t x = 0, i = 0;

    for (i = 0; i < length; i++)
    {
        x = ((crc >> 8) ^ *pdata) & 0xff;
        x ^= x >> 4;
        crc = (crc << 8) ^ (x << 12) ^ (x << 5) ^ x;
        pdata++;
    }
    return crc;
}
/*
*********************************************************************************************************
*	函 数 名: is_ipv4_addr
*	功能说明: 判断IP地址的格式是否正确。
*	形    参: ip ：地址字符串
*	返 回 值: 正确为1，否则为0。
*	备    注：允许 060.021.136.130 即开头为字符串0的情况
*********************************************************************************************************
*/
uint8_t is_ipv4_addr(char *ip)
{
    uint8_t len = 0, i = 0, count = 0, isdot = 0;
    uint16_t setions = 0;

    if (ip == NULL || ip[0] == '\0')
    {
        return 0;
    }

    len = mystrlen(ip, 15);

    for (i = 0, count = 0; i < len; i++)
    {
        if ((ip[i] != '.') && (ip[i] < '0' || ip[i] > '9'))
        {
            /* 能够筛选出 192.168. 1.1 ,19a.168.2.3 等情况 */
            return 0;
        }
        if (ip[i] == '.')
        {
            if (isdot)
                /* 能够筛选出 192..1.2 的情况 */
                return 0;

            count++;
            if (count > 3)
            {
                /* 能够筛选出 192.1.2.3. */
                return 0;
            }
            isdot = 1;
            setions = 0;
        }
        else
        {
            isdot = 0;
            setions = setions * 10 + (ip[i] - '0'); /*求每一段总和*/
            if (setions > 255)
                /* 能够筛选出 1921.168.1.1 ,192.1.2.345 等情况 */
                return 0;
        }
    }
    return 1;
}
/*
*********************************************************************************************************
*	函 数 名: TheIPFormatIsCorrect
*	功能说明: 判断IP地址的格式是否正确。
*	形    参: IPort ：地址字符串
*             type ：0--IP  1--端口
*	返 回 值: 正确为1，否则为0。
*	备    注：无
*********************************************************************************************************
*/
uint8_t TheIPFormatIsCorrect(char *IPort, uint8_t type)
{
    uint8_t i = 0, len = 0;
    uint32_t setions = 0;

    if (type == 0)
    {
        return is_ipv4_addr(IPort);
    }
    else
    {     
        len = mystrlen(IPort, 5);
        for (i = 0; i < len; i++)
        {
            if ((IPort[i] < '0' || IPort[i] > '9'))
                return 0;
            else
            {
                setions = setions * 10 + (IPort[i] - '0'); /*求每一段总和*/
                if (setions > 65535)
                    return 0;
            }
        }
    }
    return 1;
}
/*
*********************************************************************************************************
*	函 数 名: IPReduceSpotAddZero
*	功能说明: 将IP转成12字节ascii 例60.21.136.130转成060021136130
*	形    参: ip1 ：输入要转化的ip
*             ip2 ：输出转化完成的ip
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void IPReduceSpotAddZero(char *ip1, char *ip2)
{
    char changeIP[20] = {0}, Dot[4] = {0};
    uint16_t jj = 0, i = 0, len = mystrlen(ip1, 15);

    memcpy(changeIP, ip1, len);

    for (i = 0; i < 4; i++)
    {
        if (i == 1)
        {
            for (jj = 0; jj <= Dot[0] + 1; jj++)
            {
                changeIP[jj] = changeIP[jj + Dot[0] + 1];
            }
        }
        else if (i == 2)
        {
            for (jj = 0; jj <= Dot[1] + 1; jj++)
            {
                changeIP[jj] = changeIP[jj + Dot[0] + Dot[1] + 2];
            }
        }
        else if (i == 3)
        {
            for (jj = 0; jj <= Dot[2] + 3; jj++)
            {
                changeIP[jj] = changeIP[jj + Dot[0] + Dot[1] + Dot[2] + 3];
            }
            Dot[3] = len - Dot[2] - Dot[1] - Dot[0] - 3;
        }

        if (i != 3)
        {
            for (jj = 0; jj < 4; jj++)
            {
                if (changeIP[jj] == '.')
                    break;
            }
            Dot[i] = jj;
        }

        if (Dot[i] == 1)
        {
            ip2[0 + 3 * i] = '0';
            ip2[1 + 3 * i] = '0';
            ip2[2 + 3 * i] = changeIP[0];
        }
        else if (Dot[i] == 2)
        {
            ip2[0 + 3 * i] = '0';
            ip2[1 + 3 * i] = changeIP[0];
            ip2[2 + 3 * i] = changeIP[1];
        }
        else
        {
            ip2[0 + 3 * i] = changeIP[0];
            ip2[1 + 3 * i] = changeIP[1];
            ip2[2 + 3 * i] = changeIP[2];
        }
    }
}
/*
*********************************************************************************************************
*	函 数 名: PortAddZero
*	功能说明: 将端口转成自动补零的5位ascii  例3380转成03380
*	形    参: port ：输入要转化的port
*             tbf ：输出转化完成的port
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void PortAddZero(char *port, char *tbf)
{
    uint8_t len = mystrlen(port, 5), jj = 0, i = 0;
    memset(tbf, 0, 5);
    memcpy(tbf, port, len);
    for (i = 0; i < 5; i++)
    {
        if (tbf[4] == 0x00)
        {
            for (jj = 0; jj < 4 - i; jj++)
            {
                tbf[4 - jj] = tbf[3 - jj];
            }
            tbf[i] = 0x30;
        }
        else
        {
            break;
        }
    }
}
/*
*********************************************************************************************************
*	函 数 名: IPReduceZero
*	功能说明: ip去0  例060.021.136.130转成 60.21.136.130
*	形    参: IP ：输入要转化的IP
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void IPReduceZero(char *IP)
{
    char changeIP[16] = {0};
    uint8_t i = 0, j = 0, k = 0, m = 0, n = 0;

    memcpy(changeIP, IP, 15);
    memset(IP, 0, 15);

    for (j = 0; j < 4; j++)
    {
        if (changeIP[0] == '0')
        {
            for (i = 0; i < 15; i++)
            {
                changeIP[i] = changeIP[i + 1];
            }
            k++;
        }
        else
        {
            break;
        }
    }

    for (i = 1; i < 15; i++)
    {
        if ((changeIP[i] == '0') && (changeIP[i - 1] == '.'))
        {
            m++;
            for (j = i; j < (15 - k); j++)
            {
                changeIP[j] = changeIP[j + 1];
            }
            i--;
        }
    }

    for (i = 0; i < (k + m); i++)
    {
        changeIP[14 - i] = 0x00;
    }
    /* xxx.xxx.xxx.xxx */
    if (changeIP[0] == '.')
    {
        memcpy(IP, changeIP + 1, 12);
        changeIP[0] = '0';
        changeIP[1] = '.';
        memcpy(changeIP + 2, IP, 12);
        memset(IP, 0, 15);
    }

    for (i = 1; i < 8; i++)
    {
        if ((changeIP[i] == '.') && (changeIP[i + 1] == '.'))
        {
            memcpy(IP, changeIP + i + 1, 8);
            changeIP[i + 1] = '0';
            memcpy(changeIP + i + 2, IP, 8);
            memset(IP, 0, 15);
        }
    }

    for (i = 1; i < 12; i++)
    {
        if (changeIP[i] == '.')
            n = i;
    }
    if (changeIP[n + 1] == 0)
        changeIP[n + 1] = 0x30;
    memcpy(IP, changeIP, 15);
}
/*
*********************************************************************************************************
*	函 数 名: PortReduceZero
*	功能说明: 将首字符为0的port去0  例：05678转5678
*	形    参: iput   ：输入的要转换的port
*             oput   ：输出转换的port
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void PortReduceZero(char *iput, char *oput)
{
    uint8_t i = 0, jj = 0;
    memcpy(oput, iput, 5);
    for (i = 0; i < 4; i++)
    {
        if (oput[0] == 0x30)
        {
            for (jj = 0; jj < 4 - i; jj++)
            {
                oput[jj] = oput[jj + 1];
            }
            oput[4 - i] = 0x00;
        }
        else
        {
            break;
        }
    }
}
/*
*********************************************************************************************************
*	函 数 名: PortReduceZero_New
*	功能说明: 将首字符为0的port去0  例：05678转5678
*	形    参: Port ：输入的要转换的port转换完的还在这里
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void PortReduceZero_New(char *Port)
{
    uint8_t i = 0, jj = 0;
    for (i = 0; i < 4; i++)
    {
        if (Port[0] == 0x30)
        {
            for (jj = 0; jj < 4 - i; jj++)
            {
                Port[jj] = Port[jj + 1];
            }
            Port[4 - i] = 0x00;
        }
        else
        {
            break;
        }
    }
}
/*
*********************************************************************************************************
*	函 数 名: HexIPToAscii
*	功能说明: 将4字节hex的ip转成ascii  例ip[4]={0xfe,0xfe,0xfe,0xfe};转成254.254.254.254(ascii)
*	形    参: ip ：输入要转化的ip
*             changeip ：输出转化完成的ip
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void HexIPToAscii(char *ip, char *changeip)
{
    changeip[0] = (ip[0] / 100) + 0x30;
    changeip[1] = ((ip[0] % 100) / 10) + 0x30;
    changeip[2] = (ip[0] % 10) + 0x30;
    changeip[3] = '.';
    changeip[4] = (ip[1] / 100) + 0x30;
    changeip[5] = ((ip[1] % 100) / 10) + 0x30;
    changeip[6] = (ip[1] % 10) + 0x30;
    changeip[7] = '.';
    changeip[8] = (ip[2] / 100) + 0x30;
    changeip[9] = ((ip[2] % 100) / 10) + 0x30;
    changeip[10] = (ip[2] % 10) + 0x30;
    changeip[11] = '.';
    changeip[12] = (ip[3] / 100) + 0x30;
    changeip[13] = ((ip[3] % 100) / 10) + 0x30;
    changeip[14] = (ip[3] % 10) + 0x30;
}
/*
*********************************************************************************************************
*	函 数 名: HexPortToAscii
*	功能说明: 将2字节hex的port转成ascii  例port=3380;转成03380(ascii)
*	形    参: port ：输入要转化的port
*             changeport ：输出转化完成的port
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void HexPortToAscii(uint16_t port, char *changeport)
{
    changeport[0] = (port / 10000) + 0x30;
    changeport[1] = ((port % 10000) / 1000) + 0x30;
    changeport[2] = ((port % 1000) / 100) + 0x30;
    changeport[3] = ((port % 100) / 10) + 0x30;
    changeport[4] = (port % 10) + 0x30;
}
/*
*********************************************************************************************************
*	函 数 名: IPAddSpot
*	功能说明: 12长度IP无'.'转15长度有符号ip  例060021136130转成060.021.136.130
*	形    参: port ：输入要转化的port
*             changeport ：输出转化完成的port
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void IPAddSpot(char *a, char *b)
{
    uint8_t i = 0, j = 0;
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 3; j++)
        {
            b[4 * i + j] = a[3 * i + j];
        }
    }
    b[3] = '.';
    b[7] = '.';
    b[11] = '.';
}
/*
*********************************************************************************************************
*	函 数 名: camper
*	功能说明: 两个数组从起始开始进行数据比较
*	形    参: *a：目标数据地址
*             *b：目标数据地址
*             len：要比较的长度
*	返 回 值: 0：有不一样的地方  1：完全相同
*	备    注：无
*********************************************************************************************************
*/
uint8_t camper(uint8_t *a, uint8_t *b, uint8_t len)
{
    uint16_t i = 0;
    for (i = 0; i < len; i++)
    {
        if (a[i] != b[i])
        {
            return 0;
        }
    }
    return 1;
}
/*
*********************************************************************************************************
*	函 数 名: CalCheckSum
*	功能说明: 计算校验和(一字节)
*	形    参: *buf：传入的缓存
*            size：要计算的大小
*            op：0 计算校验和；1 判断校验和(要求是校验和在传入缓存的最后一个数字)
*	返 回 值: op=0：校验和;op=1：0:校验和验证失败,1:校验和验证成功
*	备    注：无
*********************************************************************************************************
*/
uint8_t CalCheckSum(uint8_t *buf, uint32_t size, uint8_t op)
{
    uint32_t i;
    uint8_t sum = 0;
    for (i = 0; i < size; i++)
    {
        sum += buf[i];
    }
    if (op)
    {
        if (sum != buf[size])
            sum = 0;
        else
            sum = 1;
    }
    return (sum);
}
/*
*********************************************************************************************************
*	函 数 名: str_len
*	功能说明: 计算字符串长度.0是结束符
*	形    参: _str : 缓冲区
*	返 回 值: 无
*********************************************************************************************************
*/
int str_len(char *_str)
{
    int len = 0;

    while (*_str++)
        len++;
    return len;
}

/*
*********************************************************************************************************
*	函 数 名: str_cpy
*	功能说明: 复制字符串
*	形    参: tar : 目标缓冲区
*			 src : 源缓冲区
*	返 回 值: 无
*********************************************************************************************************
*/
void str_cpy(char *_tar, char *_src)
{
    do
    {
        *_tar++ = *_src;
    } while (*_src++);
}

/*
*********************************************************************************************************
*	函 数 名: str_cmp
*	功能说明: 字符串比较
*	形    参: s1 : 字符串1
*			  s2 : 字符串2
*	返 回 值: 0 表示相等 非0表示不等
*********************************************************************************************************
*/
int str_cmp(char *s1, char *s2)
{
    while ((*s1 != 0) && (*s2 != 0) && (*s1 == *s2))
    {
        s1++;
        s2++;
    }
    return *s1 - *s2;
}

/*
*********************************************************************************************************
*	函 数 名: str_copy
*	功能说明: 复制字符串
*	形    参: tar : 目标缓冲区
*			 src : 源缓冲区
*	返 回 值: 无
*********************************************************************************************************
*/
void mem_set(char *_tar, char _data, int _len)
{
    while (_len--)
    {
        *_tar++ = _data;
    }
}

/*
*********************************************************************************************************
*	函 数 名: int_to_ascii
*	功能说明: 将整数转换为ASCII数组。支持负数。
*	形    参: _Number : 整数
*			 _pBuf : 目标缓冲区, 存放转换后的结果。以0结束的字符串。
*			 _len : ASCII字符个数, 字符串长度
*	返 回 值: 无
*********************************************************************************************************
*/
void int_to_str(int _iNumber, char *_pBuf, unsigned char _len)
{
    unsigned char i;
    int iTemp;

    if (_iNumber < 0) /* 负数 */
    {
        iTemp = -_iNumber; /* 转为正数 */
    }
    else
    {
        iTemp = _iNumber;
    }

    mem_set(_pBuf, ' ', _len);

    /* 将整数转换为ASCII字符串 */
    for (i = 0; i < _len; i++)
    {
        _pBuf[_len - 1 - i] = (iTemp % 10) + '0';
        iTemp = iTemp / 10;
        if (iTemp == 0)
        {
            break;
        }
    }
    _pBuf[_len] = 0;

    if (_iNumber < 0) /* 负数 */
    {
        for (i = 0; i < _len; i++)
        {
            if ((_pBuf[i] == ' ') && (_pBuf[i + 1] != ' '))
            {
                _pBuf[i] = '-';
                break;
            }
        }
    }
}

/*
*********************************************************************************************************
*	函 数 名: int_to_ascii
*	功能说明: 将整数转换为ASCII数组。支持负数。
*	形    参: _Number : 整数
*			 _pBuf : 目标缓冲区, 存放转换后的结果。以0结束的字符串。
*			 _len : ASCII字符个数, 字符串长度
*	返 回 值: 无
*********************************************************************************************************
*/
void uint_to_str(unsigned int _iNumber, char *_pBuf, unsigned char _len)
{
    unsigned char i;
    int iTemp;

    iTemp = _iNumber;

    mem_set(_pBuf, ' ', _len);

    /* 将整数转换为ASCII字符串 */
    for (i = 0; i < _len; i++)
    {
        _pBuf[_len - 1 - i] = (iTemp % 10) + '0';
        iTemp = iTemp / 10;
        if (iTemp == 0)
        {
            break;
        }
    }
    _pBuf[_len] = 0;
}

/*
*********************************************************************************************************
*	函 数 名: str_to_int
*	功能说明: 将ASCII码字符串转换成整数。 遇到小数点自动越过。
*	形    参: _pStr :待转换的ASCII码串. 可以以逗号，#或0结束。 2014-06-20 修改为非0-9的字符。
*	返 回 值: 二进制整数值
*********************************************************************************************************
*/
int str_to_int(char *_pStr)
{
    unsigned char flag;
    char *p;
    int ulInt;
    unsigned char i;
    unsigned char ucTemp;

    p = _pStr;
    if (*p == '-')
    {
        flag = 1; /* 负数 */
        p++;
    }
    else
    {
        flag = 0;
    }

    ulInt = 0;
    for (i = 0; i < 15; i++)
    {
        ucTemp = *p;
        if (ucTemp == '.') /* 遇到小数点，自动跳过1个字节 */
        {
            p++;
            ucTemp = *p;
        }
        if ((ucTemp >= '0') && (ucTemp <= '9'))
        {
            ulInt = ulInt * 10 + (ucTemp - '0');
            p++;
        }
        else
        {
            break;
        }
    }

    if (flag == 1)
    {
        return -ulInt;
    }
    return ulInt;
}

/*
*********************************************************************************************************
*	函 数 名: BEBufToUint16
*	功能说明: 将2字节数组(大端Big Endian次序，高字节在前)转换为16位整数
*	形    参: _pBuf : 数组
*	返 回 值: 16位整数值
*
*   大端(Big Endian)与小端(Little Endian)
*********************************************************************************************************
*/
uint16_t BEBufToUint16(uint8_t *_pBuf)
{
    return (((uint16_t)_pBuf[0] << 8) | _pBuf[1]);
}

/*
*********************************************************************************************************
*	函 数 名: LEBufToUint16
*	功能说明: 将2字节数组(小端Little Endian，低字节在前)转换为16位整数
*	形    参: _pBuf : 数组
*	返 回 值: 16位整数值
*********************************************************************************************************
*/
uint16_t LEBufToUint16(uint8_t *_pBuf)
{
    return (((uint16_t)_pBuf[1] << 8) | _pBuf[0]);
}

/*
*********************************************************************************************************
*	函 数 名: BEBufToUint32
*	功能说明: 将4字节数组(大端Big Endian次序，高字节在前)转换为16位整数
*	形    参: _pBuf : 数组
*	返 回 值: 16位整数值
*
*   大端(Big Endian)与小端(Little Endian)
*********************************************************************************************************
*/
uint32_t BEBufToUint32(uint8_t *_pBuf)
{
    return (((uint32_t)_pBuf[0] << 24) | ((uint32_t)_pBuf[1] << 16) | ((uint32_t)_pBuf[2] << 8) | _pBuf[3]);
}

/*
*********************************************************************************************************
*	函 数 名: LEBufToUint32
*	功能说明: 将4字节数组(小端Little Endian，低字节在前)转换为16位整数
*	形    参: _pBuf : 数组
*	返 回 值: 16位整数值
*********************************************************************************************************
*/
uint32_t LEBufToUint32(uint8_t *_pBuf)
{
    return (((uint32_t)_pBuf[3] << 24) | ((uint32_t)_pBuf[2] << 16) | ((uint32_t)_pBuf[1] << 8) | _pBuf[0]);
}

/*
*********************************************************************************************************
*	函 数 名: CRC16_Modbus
*	功能说明: 计算CRC。 用于Modbus协议。
*	形    参: _pBuf : 参与校验的数据
*			  _usLen : 数据长度
*	返 回 值: 16位整数值。 对于Modbus ，此结果高字节先传送，低字节后传送。
*
*   所有可能的CRC值都被预装在两个数组当中，当计算报文内容时可以简单的索引即可；
*   一个数组包含有16位CRC域的所有256个可能的高位字节，另一个数组含有低位字节的值；
*   这种索引访问CRC的方式提供了比对报文缓冲区的每一个新字符都计算新的CRC更快的方法；
*
*  注意：此程序内部执行高/低CRC字节的交换。此函数返回的是已经经过交换的CRC值；也就是说，该函数的返回值可以直接放置
*        于报文用于发送；
*********************************************************************************************************
*/
uint16_t CRC16_Modbus(uint8_t *_pBuf, uint16_t _usLen)
{
    uint8_t ucCRCHi = 0xFF; /* 高CRC字节初始化 */
    uint8_t ucCRCLo = 0xFF; /* 低CRC 字节初始化 */
    uint16_t usIndex;       /* CRC循环中的索引 */

    while (_usLen--)
    {
        usIndex = ucCRCHi ^ *_pBuf++; /* 计算CRC */
        ucCRCHi = ucCRCLo ^ s_CRCHi[usIndex];
        ucCRCLo = s_CRCLo[usIndex];
    }
    return ((uint16_t)ucCRCHi << 8 | ucCRCLo);
}

/*
*********************************************************************************************************
*	函 数 名: CaculTwoPoint
*	功能说明: 根据2点直线方程，计算Y值
*	形    参:  2个点的坐标和x输入量
*	返 回 值: x对应的y值
*********************************************************************************************************
*/
int32_t CaculTwoPoint(int32_t x1, int32_t y1, int32_t x2, int32_t y2, int32_t x)
{
    return y1 + ((int64_t)(y2 - y1) * (x - x1)) / (x2 - x1);
}

/*
*********************************************************************************************************
*	函 数 名: AsciiToUint32
*	功能说明: 变长的 ASCII 字符转换为32位整数  ASCII 字符以空格或者0结束 。 支持16进制和10进制输入
*	形    参: *pAscii ：要转换的ASCII码
*	返 回 值: 转换得到的整数
*********************************************************************************************************
*/
uint32_t AsciiToUint32(char *pAscii)
{
    char i;
    char bTemp;
    char bIsHex;
    char bLen;
    char bZeroLen;
    uint32_t lResult;
    uint32_t lBitValue;

    /* 判断是否是16进制数 */
    bIsHex = 0;
    if ((pAscii[0] == '0') && ((pAscii[1] == 'x') || (pAscii[1] == 'X')))
    {
        bIsHex = 1;
    }

    lResult = 0;
    // 最大数值为 4294967295, 10位+2字符"0x" //
    if (bIsHex == 0)
    { // 十进制 //
        // 求长度 //
        lBitValue = 1;

        /* 前导去0 */
        for (i = 0; i < 8; i++)
        {
            bTemp = pAscii[i];
            if (bTemp != '0')
                break;
        }
        bZeroLen = i;

        for (i = 0; i < 10; i++)
        {
            if ((pAscii[i] < '0') || (pAscii[i] > '9'))
                break;
            lBitValue = lBitValue * 10;
        }
        bLen = i;
        lBitValue = lBitValue / 10;
        if (lBitValue == 0)
            lBitValue = 1;
        for (i = bZeroLen; i < bLen; i++)
        {
            lResult += (pAscii[i] - '0') * lBitValue;
            lBitValue /= 10;
        }
    }
    else
    { /* 16进制 */
        /* 求长度 */
        lBitValue = 1;

        /* 前导去0 */
        for (i = 0; i < 8; i++)
        {
            bTemp = pAscii[i + 2];
            if (bTemp != '0')
                break;
        }
        bZeroLen = i;
        for (; i < 8; i++)
        {
            bTemp = pAscii[i + 2];
            if (((bTemp >= 'A') && (bTemp <= 'F')) ||
                ((bTemp >= 'a') && (bTemp <= 'f')) ||
                ((bTemp >= '0') && (bTemp <= '9')))
            {
                lBitValue = lBitValue * 16;
            }
            else
            {
                break;
            }
        }
        lBitValue = lBitValue / 16;
        if (lBitValue == 0)
            lBitValue = 1;
        bLen = i;
        for (i = bZeroLen; i < bLen; i++)
        {
            bTemp = pAscii[i + 2];
            if ((bTemp >= 'A') && (bTemp <= 'F'))
            {
                bTemp -= 0x37;
            }
            else if ((bTemp >= 'a') && (bTemp <= 'f'))
            {
                bTemp -= 0x57;
            }
            else if ((bTemp >= '0') && (bTemp <= '9'))
            {
                bTemp -= '0';
            }
            lResult += bTemp * lBitValue;
            lBitValue /= 16;
        }
    }
    return lResult;
}

/*
*********************************************************************************************************
*	函 数 名: Bcd_to_Int
*	功能说明: 
*	形    参:
*	返 回 值: 
*********************************************************************************************************
*/
unsigned char Bcd_to_Int(unsigned char i)
{
    return (i / 16 * 10 + i % 16);
}

/*
*********************************************************************************************************
*	函 数 名: Int_to_Bcd
*	功能说明: 
*	形    参: 
*	返 回 值:
*********************************************************************************************************
*/
unsigned char Int_to_Bcd(unsigned char i)
{
    return (i / 10 * 16 + i % 10);
}

/*
*********************************************************************************************************
*	函 数 名: Find_Max
*	功能说明: 
*	形    参: *buf 
*	返 回 值:数组里面的最大值
*********************************************************************************************************
*/
uint16_t Find_Max(uint16_t *buf)
{
    uint16_t i, max;

    max = buf[0];
    for (i = 1; i < sizeof(buf); i++)
    {
        if (max < buf[i])
        {
            max = buf[i];
        }
    }
    return max;
}

/*
*********************************************************************************************************
*	函 数 名: Find_Min
*	功能说明: 
*	形    参: *buf 
*	返 回 值:数组里面的最小值
*********************************************************************************************************
*/
uint16_t Find_Min(uint16_t *buf)
{
    unsigned int i, min;

    min = buf[0];
    for (i = 1; i < sizeof(buf); i++)
    {
        if (min < buf[i])
        {
            min = buf[i];
        }
    }
    return min;
}
