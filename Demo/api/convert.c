/*
*********************************************************************************************************
*
*	模块名称 : 数据转换程序
*	文件名称 : convert.c
*	版    本 : V1.0.0
*	说    明 : 全部API用到的数据转化或者通用的函数都在这里
*	修改记录 :
*
*		版本号     日期      作者    说明
*		V1.0.0  2020-12-31  高屹    正式发布
*		V1.0.1  2020-2-1    高屹    新增ipv4全面判断，代替原先的ip判断方式
*
*	Copyright (C), 2020-2030,  辽宁思凯-高屹
*
*********************************************************************************************************
*/
#include "convert.h"

/*
*********************************************************************************************************
*	函 数 名: mystrlen
*	功能说明: 计算指定长度字符串长度
*	形    参: s   ：输入的字符串
*             len ：长度限制
*	返 回 值: 转换结果
*	备    注：无
*********************************************************************************************************
*/
size_t mystrlen(const char *s, uint16_t len)
{
    /* find length of s[] */
    const char *sc;
    uint16_t i = 0;

    for (sc = s; *sc != '\0'; ++sc)
    {
        i++;
        if (i > len)
            break;
    }
    return (sc - s);
}
/*
*********************************************************************************************************
*	函 数 名: strnstr
*	功能说明: 比较两个字符串是否有相同内容，限制长度，并且比较长度
*	形    参: src   ：需要比较的母串
*             substr ：需要比较的子串
*             len ： 需要比较的长度
*             limt_len ： 限制长度
*	返 回 值: 转换结果
*	备    注：无
*********************************************************************************************************
*/
char *strnstr(const char *src, const char *substr, uint8_t len, uint8_t limt_len)
{
    const char *p;

    if (src == NULL || 0 == *src || substr == NULL || 0 == *substr || limt_len == 0 || len == 0)
    {
        return NULL;
    }

    p = src;

    while (limt_len)
    {
        if (*p == *substr)
        {
            if (memcmp(p, substr, len) == 0)
            {
                return (char *)p;
            }
        }
        p++;
        limt_len--;
    }

    return NULL;
}
/*
*********************************************************************************************************
*	函 数 名: BinToChar
*	功能说明: 将BCD码转为ASCII字符。 比如 0x0A ==> 'A' 16进制数0-15转成ascii的'0'-'9'和'a'-'f'
*	形    参: _bcd   ：输入的二进制数。必须小于16
*	返 回 值: 转换结果
*	备    注：无
*********************************************************************************************************
*/
char BinToChar(uint8_t _bcd)
{
    if (_bcd < 10)
    {
        return _bcd + '0';
    }
    else if (_bcd < 16)
    {
        return _bcd + 'A';
    }
    else
    {
        return 0;
    }
}
/*
*********************************************************************************************************
*	函 数 名: HexToAscll
*	功能说明: 将二进制数组转换为16进制格式的ASCII字符串。
*			  		0x12 0x34 转化为 0x31 0x32 0x33 0x34  即 "1234"
*	形    参: p2 ：输入的数据，二进制数组
*			  p1 ：存放转换结果, ASCII字符串，\0结束。1个二进制对应2个ASCII字符.
*	返 回 值: 无
*	备    注：小心数组溢出 p1的大小至少是p2大小的 2n+1 倍！！！
*********************************************************************************************************
*/
void HexToAscll(char *p1, uint8_t *p2, uint16_t length)
{
    uint32_t i = 0, k = 0;
    for (i = 0; i < length; i++)
    {
        k = i << 1;
        /* 高半字节 */
        p1[k] = p2[i] & 0xf0;
        p1[k] >>= 4;
        if (p1[k] <= 9)
        {
            p1[k] |= 0x30;
        }
        else if (p1[k] <= 15)
        {
            p1[k] = p1[k] - 10 + 'A';
        }
        /* 低半字节 */
        p1[k + 1] = p2[i] & 0x0f;
        if (p1[k + 1] <= 9)
        {
            p1[k + 1] |= 0x30;
        }
        else if (p1[k + 1] <= 15)
        {
            p1[k + 1] = p1[k + 1] - 10 + 'A';
        }
    }
    p1[2 * length] = '\0'; /* 字符结束 */
}
/*
*********************************************************************************************************
*	函 数 名: AsciiToHex
*	功能说明: 将ASCII字符串转成16进制格式的数组。
*			  0x31 0x32 0x33 0x34  即 "1234"  转化为  0x12 0x34
*	形    参: 	_pHex   ：输入的数据，二进制数组
*				_pAscii ：存放转换结果, ASCII字符串，0结束。1个二进制对应2个ASCII字符.
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void AsciiToHex(uint8_t *code, uint8_t *decode, uint16_t len)
{
    uint16_t i = 0;
    uint8_t j = 0, k = 0;
    for (i = 0; i < len; i++)
    {
        if ((code[i * 2] <= 0x39) && (code[i * 2] >= 0x30))
        {
            j = code[i * 2] - 0x30;
        }
        else if ((code[i * 2] <= 0x46) && (code[i * 2] >= 0x40))
        {
            j = code[i * 2] - 0x40 + 0x09;
        }
        else if ((code[i * 2] <= 0x66) && (code[i * 2] >= 0x60))
        {
            j = code[i * 2] - 0x60 + 0x09;
        }
        if ((code[i * 2 + 1] <= 0x39) && (code[i * 2 + 1] >= 0x30))
        {
            k = code[i * 2 + 1] - 0x30;
        }
        else if ((code[i * 2 + 1] <= 0x46) && (code[i * 2 + 1] >= 0x40))
        {
            k = code[i * 2 + 1] - 0x40 + 0x09;
        }
        else if ((code[i * 2 + 1] <= 0x66) && (code[i * 2 + 1] >= 0x60))
        {
            k = code[i * 2 + 1] - 0x60 + 0x09;
        }
        decode[i] = ((j << 4) + k);
    }
}
/*
*********************************************************************************************************
*	函 数 名: CharToHex
*	功能说明: char 转 hex  ASCII的'0'-'9' 'a'-'f' 'A'-'F' 转成 0-15
*	形    参: cd : 待转换的ASCII码字符
*	返 回 值: 转化后的hex
*	备    注：无
*********************************************************************************************************
*/
uint8_t CharToHex(char ch)
{
    if ((ch >= '0') && (ch <= '9'))
        return ch - 0x30;
    else if ((ch >= 'A') && (ch <= 'F'))
        return ch - 'A' + 10;
    else if ((ch >= 'a') && (ch <= 'f'))
        return ch - 'a' + 10;
    else
        return (0x20);
}
/*
*********************************************************************************************************
*	函 数 名: CharToBety
*	功能说明: char 转 bety
*	形    参: iput : 待转换的ASCII码串
*             oput : 目标缓冲区, 存放转换后的结果。
*             len : 整数 要转的长度
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void CharToBety(uint8_t *iput, uint8_t *oput, uint8_t len)
{
    uint8_t i = 0, b = 0;
    for (i = 0; i < len; i++)
    {
        b = CharToHex(iput[i << 1]) << 4;
        b += CharToHex(iput[(i << 1) + 1]);
        oput[i] = b;
    }
}
/*
*********************************************************************************************************
*	函 数 名: HEXtoBCD
*	功能说明:
*	形    参:
*	返 回 值:
*	备    注：无
*********************************************************************************************************
*/
uint8_t HEXtoBCD(uint8_t hex_data)
{
    return (hex_data / 10 * 16 + hex_data % 10);
}

/*
*********************************************************************************************************
*	函 数 名: BCDtoHEX
*	功能说明:
*	形    参:
*	返 回 值:
*	备    注：无
*********************************************************************************************************
*/
uint8_t BCDtoHEX(uint8_t bcd_data)
{
    return (bcd_data / 16 * 10 + bcd_data % 16);
}
/*
*********************************************************************************************************
*	函 数 名: MathCrc16
*	功能说明: CRC16
*	形    参:
*	返 回 值:
*	备    注：无
*********************************************************************************************************
*/
uint16_t MathCrc16(uint8_t *ptr, uint16_t len)
{
    uint16_t crc_val = 0xffff;
    uint16_t tmp = 0;
    uint16_t i = 0;
    while (len > 0)
    {
        crc_val ^= *ptr;
        ptr++;
        for (i = 0; i < 8; i++)
        {
            tmp = crc_val;
            crc_val >>= 1; /* CRC 校验字节的右移，最低位到 C，最高位补 0 */
            if ((tmp & 0x01) == 1)
                crc_val ^= 0xA001; /* 采用的多项式是： 0xA001 */
        }
        len--;
    }
    return (crc_val);
}
/*
*********************************************************************************************************
*	函 数 名: CheckSum
*	功能说明: 计算校验和
*	形    参: parray校验对象，size对象长度，op->操作类型0表示计算和，非0表示校验
*	返 回 值: 0表示校验和不正确，非零表示返回的的计算和。
*	备    注：无
*********************************************************************************************************
*/
uint8_t CheckSum(uint8_t *parray, uint32_t size, uint8_t op)
{
    uint32_t i = 0;
    uint8_t sum = 0;
    for (i = 0; i < size; i++)
    {
        sum += parray[i];
    }
    if (op)
    {
        if (sum != parray[size])
            sum = 0;
        else
            sum = 1;
    }
    return (sum);
}
/*
*********************************************************************************************************
*	函 数 名: calcCheckCrc
*	功能说明: 计算CRC
*	形    参: pdata校验对象，length对象长度
*	返 回 值: 返回CRC。
*	备    注：无
*********************************************************************************************************
*/
uint16_t calcCheckCrc(uint8_t *pdata, uint16_t length)
{
    uint16_t crc = 0xffff;
    uint32_t x = 0, i = 0;

    for (i = 0; i < length; i++)
    {
        x = ((crc >> 8) ^ *pdata) & 0xff;
        x ^= x >> 4;
        crc = (crc << 8) ^ (x << 12) ^ (x << 5) ^ x;
        pdata++;
    }
    return crc;
}
/*
*********************************************************************************************************
*	函 数 名: is_ipv4_addr
*	功能说明: 判断IP地址的格式是否正确。
*	形    参: ip ：地址字符串
*	返 回 值: 正确为1，否则为0。
*	备    注：允许 060.021.136.130 即开头为字符串0的情况
*********************************************************************************************************
*/
uint8_t is_ipv4_addr(char *ip)
{
    uint8_t len = 0, i = 0, count = 0, isdot = 0;
    uint16_t setions = 0;

    if (ip == NULL || ip[0] == '\0')
    {
        return 0;
    }

    len = mystrlen(ip, 15);

    for (i = 0, count = 0; i < len; i++)
    {
        if ((ip[i] != '.') && (ip[i] < '0' || ip[i] > '9'))
        {
            /* 能够筛选出 192.168. 1.1 ,19a.168.2.3 等情况 */
            return 0;
        }
        if (ip[i] == '.')
        {
            if (isdot)
                /* 能够筛选出 192..1.2 的情况 */
                return 0;

            count++;
            if (count > 3)
            {
                /* 能够筛选出 192.1.2.3. */
                return 0;
            }
            isdot = 1;
            setions = 0;
        }
        else
        {
            isdot = 0;
            setions = setions * 10 + (ip[i] - '0'); /*求每一段总和*/
            if (setions > 255)
                /* 能够筛选出 1921.168.1.1 ,192.1.2.345 等情况 */
                return 0;
        }
    }
    return 1;
}
/*
*********************************************************************************************************
*	函 数 名: TheIPFormatIsCorrect
*	功能说明: 判断IP地址的格式是否正确。
*	形    参: IPort ：地址字符串
*             type ：0--IP  1--端口
*	返 回 值: 正确为1，否则为0。
*	备    注：无
*********************************************************************************************************
*/
uint8_t TheIPFormatIsCorrect(char *IPort, uint8_t type)
{
    uint8_t i = 0, len = 0;
    uint32_t setions = 0;

    if (type == 0)
    {
        return is_ipv4_addr(IPort);
    }
    else
    {     
        len = mystrlen(IPort, 5);
        for (i = 0; i < len; i++)
        {
            if ((IPort[i] < '0' || IPort[i] > '9'))
                return 0;
            else
            {
                setions = setions * 10 + (IPort[i] - '0'); /*求每一段总和*/
                if (setions > 65535)
                    return 0;
            }
        }
    }
    return 1;
}
/*
*********************************************************************************************************
*	函 数 名: IPReduceSpotAddZero
*	功能说明: 将IP转成12字节ascii 例60.21.136.130转成060021136130
*	形    参: ip1 ：输入要转化的ip
*             ip2 ：输出转化完成的ip
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void IPReduceSpotAddZero(char *ip1, char *ip2)
{
    char changeIP[20] = {0}, Dot[4] = {0};
    uint16_t jj = 0, i = 0, len = mystrlen(ip1, 15);

    memcpy(changeIP, ip1, len);

    for (i = 0; i < 4; i++)
    {
        if (i == 1)
        {
            for (jj = 0; jj <= Dot[0] + 1; jj++)
            {
                changeIP[jj] = changeIP[jj + Dot[0] + 1];
            }
        }
        else if (i == 2)
        {
            for (jj = 0; jj <= Dot[1] + 1; jj++)
            {
                changeIP[jj] = changeIP[jj + Dot[0] + Dot[1] + 2];
            }
        }
        else if (i == 3)
        {
            for (jj = 0; jj <= Dot[2] + 3; jj++)
            {
                changeIP[jj] = changeIP[jj + Dot[0] + Dot[1] + Dot[2] + 3];
            }
            Dot[3] = len - Dot[2] - Dot[1] - Dot[0] - 3;
        }

        if (i != 3)
        {
            for (jj = 0; jj < 4; jj++)
            {
                if (changeIP[jj] == '.')
                    break;
            }
            Dot[i] = jj;
        }

        if (Dot[i] == 1)
        {
            ip2[0 + 3 * i] = '0';
            ip2[1 + 3 * i] = '0';
            ip2[2 + 3 * i] = changeIP[0];
        }
        else if (Dot[i] == 2)
        {
            ip2[0 + 3 * i] = '0';
            ip2[1 + 3 * i] = changeIP[0];
            ip2[2 + 3 * i] = changeIP[1];
        }
        else
        {
            ip2[0 + 3 * i] = changeIP[0];
            ip2[1 + 3 * i] = changeIP[1];
            ip2[2 + 3 * i] = changeIP[2];
        }
    }
}
/*
*********************************************************************************************************
*	函 数 名: PortAddZero
*	功能说明: 将端口转成自动补零的5位ascii  例3380转成03380
*	形    参: port ：输入要转化的port
*             tbf ：输出转化完成的port
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void PortAddZero(char *port, char *tbf)
{
    uint8_t len = mystrlen(port, 5), jj = 0, i = 0;
    memset(tbf, 0, 5);
    memcpy(tbf, port, len);
    for (i = 0; i < 5; i++)
    {
        if (tbf[4] == 0x00)
        {
            for (jj = 0; jj < 4 - i; jj++)
            {
                tbf[4 - jj] = tbf[3 - jj];
            }
            tbf[i] = 0x30;
        }
        else
        {
            break;
        }
    }
}
/*
*********************************************************************************************************
*	函 数 名: IPReduceZero
*	功能说明: ip去0  例060.021.136.130转成 60.21.136.130
*	形    参: IP ：输入要转化的IP
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void IPReduceZero(char *IP)
{
    char changeIP[16] = {0};
    uint8_t i = 0, j = 0, k = 0, m = 0, n = 0;

    memcpy(changeIP, IP, 15);
    memset(IP, 0, 15);

    for (j = 0; j < 4; j++)
    {
        if (changeIP[0] == '0')
        {
            for (i = 0; i < 15; i++)
            {
                changeIP[i] = changeIP[i + 1];
            }
            k++;
        }
        else
        {
            break;
        }
    }

    for (i = 1; i < 15; i++)
    {
        if ((changeIP[i] == '0') && (changeIP[i - 1] == '.'))
        {
            m++;
            for (j = i; j < (15 - k); j++)
            {
                changeIP[j] = changeIP[j + 1];
            }
            i--;
        }
    }

    for (i = 0; i < (k + m); i++)
    {
        changeIP[14 - i] = 0x00;
    }
    /* xxx.xxx.xxx.xxx */
    if (changeIP[0] == '.')
    {
        memcpy(IP, changeIP + 1, 12);
        changeIP[0] = '0';
        changeIP[1] = '.';
        memcpy(changeIP + 2, IP, 12);
        memset(IP, 0, 15);
    }

    for (i = 1; i < 8; i++)
    {
        if ((changeIP[i] == '.') && (changeIP[i + 1] == '.'))
        {
            memcpy(IP, changeIP + i + 1, 8);
            changeIP[i + 1] = '0';
            memcpy(changeIP + i + 2, IP, 8);
            memset(IP, 0, 15);
        }
    }

    for (i = 1; i < 12; i++)
    {
        if (changeIP[i] == '.')
            n = i;
    }
    if (changeIP[n + 1] == 0)
        changeIP[n + 1] = 0x30;
    memcpy(IP, changeIP, 15);
}
/*
*********************************************************************************************************
*	函 数 名: PortReduceZero
*	功能说明: 将首字符为0的port去0  例：05678转5678
*	形    参: iput   ：输入的要转换的port
*             oput   ：输出转换的port
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void PortReduceZero(char *iput, char *oput)
{
    uint8_t i = 0, jj = 0;
    memcpy(oput, iput, 5);
    for (i = 0; i < 4; i++)
    {
        if (oput[0] == 0x30)
        {
            for (jj = 0; jj < 4 - i; jj++)
            {
                oput[jj] = oput[jj + 1];
            }
            oput[4 - i] = 0x00;
        }
        else
        {
            break;
        }
    }
}
/*
*********************************************************************************************************
*	函 数 名: PortReduceZero_New
*	功能说明: 将首字符为0的port去0  例：05678转5678
*	形    参: Port ：输入的要转换的port转换完的还在这里
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void PortReduceZero_New(char *Port)
{
    uint8_t i = 0, jj = 0;
    for (i = 0; i < 4; i++)
    {
        if (Port[0] == 0x30)
        {
            for (jj = 0; jj < 4 - i; jj++)
            {
                Port[jj] = Port[jj + 1];
            }
            Port[4 - i] = 0x00;
        }
        else
        {
            break;
        }
    }
}
/*
*********************************************************************************************************
*	函 数 名: HexIPToAscii
*	功能说明: 将4字节hex的ip转成ascii  例ip[4]={0xfe,0xfe,0xfe,0xfe};转成254.254.254.254(ascii)
*	形    参: ip ：输入要转化的ip
*             changeip ：输出转化完成的ip
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void HexIPToAscii(char *ip, char *changeip)
{
    changeip[0] = (ip[0] / 100) + 0x30;
    changeip[1] = ((ip[0] % 100) / 10) + 0x30;
    changeip[2] = (ip[0] % 10) + 0x30;
    changeip[3] = '.';
    changeip[4] = (ip[1] / 100) + 0x30;
    changeip[5] = ((ip[1] % 100) / 10) + 0x30;
    changeip[6] = (ip[1] % 10) + 0x30;
    changeip[7] = '.';
    changeip[8] = (ip[2] / 100) + 0x30;
    changeip[9] = ((ip[2] % 100) / 10) + 0x30;
    changeip[10] = (ip[2] % 10) + 0x30;
    changeip[11] = '.';
    changeip[12] = (ip[3] / 100) + 0x30;
    changeip[13] = ((ip[3] % 100) / 10) + 0x30;
    changeip[14] = (ip[3] % 10) + 0x30;
}
/*
*********************************************************************************************************
*	函 数 名: HexPortToAscii
*	功能说明: 将2字节hex的port转成ascii  例port=3380;转成03380(ascii)
*	形    参: port ：输入要转化的port
*             changeport ：输出转化完成的port
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void HexPortToAscii(uint16_t port, char *changeport)
{
    changeport[0] = (port / 10000) + 0x30;
    changeport[1] = ((port % 10000) / 1000) + 0x30;
    changeport[2] = ((port % 1000) / 100) + 0x30;
    changeport[3] = ((port % 100) / 10) + 0x30;
    changeport[4] = (port % 10) + 0x30;
}
/*
*********************************************************************************************************
*	函 数 名: IPAddSpot
*	功能说明: 12长度IP无'.'转15长度有符号ip  例060021136130转成060.021.136.130
*	形    参: port ：输入要转化的port
*             changeport ：输出转化完成的port
*	返 回 值: 无
*	备    注：无
*********************************************************************************************************
*/
void IPAddSpot(char *a, char *b)
{
    uint8_t i = 0, j = 0;
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 3; j++)
        {
            b[4 * i + j] = a[3 * i + j];
        }
    }
    b[3] = '.';
    b[7] = '.';
    b[11] = '.';
}
/*
*********************************************************************************************************
*	函 数 名: camper
*	功能说明: 两个数组从起始开始进行数据比较
*	形    参: *a：目标数据地址
*             *b：目标数据地址
*             len：要比较的长度
*	返 回 值: 0：有不一样的地方  1：完全相同
*	备    注：无
*********************************************************************************************************
*/
uint8_t camper(uint8_t *a, uint8_t *b, uint8_t len)
{
    uint16_t i = 0;
    for (i = 0; i < len; i++)
    {
        if (a[i] != b[i])
        {
            return 0;
        }
    }
    return 1;
}
